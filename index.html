<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RodeCODEX — 3D Driving Learner</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0a0a0a; }
    #renderCanvas { width: 100%; height: 100%; display: block; }
    .hud { position: fixed; top: 12px; left: 12px; z-index: 10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: #e8f0fe; }
    .hud .panel { background: rgba(0,0,0,0.45); padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px); box-shadow: 0 6px 20px rgba(0,0,0,.35); }
    .hud h1 { margin: 0 0 6px; font-size: 16px; font-weight: 700; letter-spacing: .3px; }
    .hud p { margin: 4px 0; font-size: 13px; }
    .controls { position: fixed; bottom: 12px; left: 12px; right: 12px; display: flex; gap: 12px; flex-wrap: wrap; z-index: 10; }
    .chip { padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,.06); color: #d7d7d7; font-size: 12px; border: 1px solid rgba(255,255,255,.12); }
  </style>
  <!-- Babylon.js + physics (Cannon.js) from CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div class="hud">
    <div class="panel">
      <h1>RodeCODEX — 3D Driving Learner</h1>
      <p><strong>Speed:</strong> <span id="speed">0</span> km/h · <strong>Gear:</strong> <span id="gear">N</span></p>
      <p><strong>Lesson:</strong> <span id="lesson">Free Drive</span></p>
    </div>
  </div>
  <div class="controls">
    <div class="chip">W/S = Throttle/Brake</div>
    <div class="chip">A/D = Steer</div>
    <div class="chip">Space = Handbrake</div>
    <div class="chip">R = Reset car</div>
    <div class="chip">C = Change camera</div>
  </div>

  <script>
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, { stencil: true, preserveDrawingBuffer: true });

    // Basic tuning parameters (easy to tweak!)
    const TUNING = {
      engineForce: 3800,      // forward force (N)
      brakeForce: 5200,       // brake force (N)
      handbrakeForce: 9000,   // extra brake
      maxSteer: 0.45,         // radians (~25.8°)
      steerSpeed: 2.5,        // how fast wheels turn
      drag: 0.425,            // air drag coefficient (approx)
      rollingResistance: 18,  // rolling resistance (tunable)
      mass: 1200,             // kg (small hatchback)
      maxSpeedKmh: 140,
    };

    const input = { fwd: 0, steer: 0, brake: 0, handbrake: 0 };

    const createScene = () => {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.02, 0.03, 0.05, 1);

      // Physics
      const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
      const physicsPlugin = new BABYLON.CannonJSPlugin();
      scene.enablePhysics(gravityVector, physicsPlugin);

      // Lights
      const sun = new BABYLON.DirectionalLight('sun', new BABYLON.Vector3(-0.6, -1, 0.2), scene);
      sun.intensity = 1.2;
      const hemi = new BABYLON.HemisphericLight('hemi', new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.4;

      // Sky
      const sky = BABYLON.Mesh.CreateSphere('sky', 16, 2000, scene);
      const skyMat = new BABYLON.StandardMaterial('skyMat', scene);
      skyMat.backFaceCulling = false;
      skyMat.emissiveColor = new BABYLON.Color3(0.08, 0.1, 0.15);
      sky.material = skyMat; sky.isPickable = false;

      // Ground (multi-lane road)
      const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 200, height: 800, subdivisions: 4 }, scene);
      const roadMat = new BABYLON.StandardMaterial('roadMat', scene);
      roadMat.diffuseColor = new BABYLON.Color3(0.13, 0.13, 0.13);
      roadMat.specularColor = new BABYLON.Color3(0.02, 0.02, 0.02);
      ground.material = roadMat;
      ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.9, restitution: 0.1 }, scene);

      // Lane markings
      const laneMat = new BABYLON.StandardMaterial('laneMat', scene);
      laneMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
      for (let i = -3; i <= 3; i++) {
        if (i === 0) continue;
        for (let j = -18; j <= 18; j++) {
          const stripe = BABYLON.MeshBuilder.CreateBox(`stripe_${i}_${j}`, { width: 0.15, height: 0.02, depth: 3 }, scene);
          stripe.position.x = i * 6; stripe.position.y = 0.02; stripe.position.z = j * 10;
          stripe.material = laneMat; stripe.isPickable = false;
        }
      }

      // Guard rails
      const mkRail = (x) => {
        const rail = BABYLON.MeshBuilder.CreateBox('rail', { width: 0.2, height: 1, depth: 800 }, scene);
        rail.position.set(x, 0.5, 0);
        const m = new BABYLON.StandardMaterial('railMat', scene); m.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7); m.specularPower = 16; rail.material = m;
        rail.physicsImpostor = new BABYLON.PhysicsImpostor(rail, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.1, friction: 0.6 }, scene);
        return rail;
      };
      mkRail(-18); mkRail(18);

      // Cones / obstacles
      const coneMat = new BABYLON.StandardMaterial('coneMat', scene); coneMat.diffuseColor = new BABYLON.Color3(1.0, 0.35, 0.05);
      for (let i = 0; i < 14; i++) {
        const cone = BABYLON.MeshBuilder.CreateCylinder('cone', { diameterTop: 0, diameterBottom: 0.5, height: 0.8, tessellation: 14 }, scene);
        cone.position.set((Math.random() * 20 - 10), 0.4, -200 - Math.random() * 350);
        cone.material = coneMat;
        cone.physicsImpostor = new BABYLON.PhysicsImpostor(cone, BABYLON.PhysicsImpostor.CylinderImpostor, { mass: 1, friction: 0.9, restitution: 0.1 }, scene);
      }

      // Car (simple chassis box with physics)
      const chassis = BABYLON.MeshBuilder.CreateBox('chassis', { width: 1.8, height: 1.2, depth: 3.6 }, scene);
      chassis.position.set(0, 1.2, 300);
      const carMat = new BABYLON.StandardMaterial('carMat', scene);
      carMat.diffuseColor = new BABYLON.Color3(0.1, 0.4, 0.95); carMat.specularPower = 64;
      chassis.material = carMat;
      chassis.physicsImpostor = new BABYLON.PhysicsImpostor(chassis, BABYLON.PhysicsImpostor.BoxImpostor, {
        mass: TUNING.mass, friction: 0.8, restitution: 0.05
      }, scene);

      // Fake wheels (visual only for now)
      const mkWheel = (dx, dz) => {
        const w = BABYLON.MeshBuilder.CreateTorus('wheel', { diameter: 0.9, thickness: 0.3, tessellation: 20 }, scene);
        w.parent = chassis; w.position.set(dx, -0.5, dz); w.rotation.z = Math.PI / 2; return w;
      };
      mkWheel(-0.8, 1.2); mkWheel(0.8, 1.2); mkWheel(-0.8, -1.2); mkWheel(0.8, -1.2);

      // Cameras: follow + hood view
      const followCam = new BABYLON.FollowCamera('followCam', new BABYLON.Vector3(0, 5, -10), scene);
      followCam.lockedTarget = chassis; followCam.radius = 12; followCam.heightOffset = 4; followCam.rotationOffset = 180; followCam.cameraAcceleration = 0.05; followCam.maxCameraSpeed = 100;

      const hoodCam = new BABYLON.UniversalCamera('hoodCam', new BABYLON.Vector3(0, 1.6, 1.2), scene);
      hoodCam.parent = chassis; hoodCam.fov = 1.1;

      let activeCam = followCam; scene.activeCamera = activeCam; activeCam.attachControl(canvas, true);

      // Headlights (simple spots)
      const headL = new BABYLON.SpotLight('headL', new BABYLON.Vector3(-0.6, 0.6, 1.8), new BABYLON.Vector3(0, -0.1, 1), Math.PI / 3, 12, scene);
      const headR = new BABYLON.SpotLight('headR', new BABYLON.Vector3(0.6, 0.6, 1.8), new BABYLON.Vector3(0, -0.1, 1), Math.PI / 3, 12, scene);
      headL.parent = chassis; headR.parent = chassis; headL.intensity = headR.intensity = 8;

      // UI
      const speedEl = document.getElementById('speed');
      const gearEl = document.getElementById('gear');

      // Input handling
      const keys = { w:false, s:false, a:false, d:false, space:false };
      window.addEventListener('keydown', (e) => { if (e.repeat) return; switch(e.key.toLowerCase()){
        case 'w': keys.w = true; break; case 's': keys.s = true; break; case 'a': keys.a = true; break; case 'd': keys.d = true; break; case ' ': keys.space = true; break;
        case 'r': resetCar(); break; case 'c': toggleCamera(); break;
      }});
      window.addEventListener('keyup', (e) => { switch(e.key.toLowerCase()){
        case 'w': keys.w = false; break; case 's': keys.s = false; break; case 'a': keys.a = false; break; case 'd': keys.d = false; break; case ' ': keys.space = false; break;
      }});

      function toggleCamera(){
        activeCam.detachControl();
        activeCam = activeCam === followCam ? hoodCam : followCam;
        scene.activeCamera = activeCam; activeCam.attachControl(canvas, true);
      }

      function resetCar(){
        chassis.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());
        chassis.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());
        chassis.rotationQuaternion = null; // allow manual reset
        chassis.rotation.set(0, Math.PI, 0);
        chassis.position.set(0, 1.2, 300);
      }

      // Driving loop (simple but convincing)
      let steerAngle = 0; // radians
      scene.onBeforeRenderObservable.add(() => {
        const dt = engine.getDeltaTime() / 1000; // seconds
        const vel = chassis.physicsImpostor.getLinearVelocity();
        const speed = vel.length(); // m/s
        const speedKmh = Math.round(speed * 3.6);
        speedEl.textContent = String(speedKmh);

        // Inputs → intent
        const wantThrottle = keys.w ? 1 : 0;
        const wantBrake = keys.s ? 1 : 0;
        const wantHandbrake = keys.space ? 1 : 0;
        const wantSteer = (keys.a ? 1 : 0) * -1 + (keys.d ? 1 : 0) * 1; // -1..1

        // Steering smoothing & speed-based limit
        const maxSteerNow = TUNING.maxSteer * Math.max(0.35, 1 - (speedKmh / (TUNING.maxSpeedKmh * 1.2)));
        steerAngle += (wantSteer * maxSteerNow - steerAngle) * Math.min(1, TUNING.steerSpeed * dt);

        // Car forward vector (on XZ plane)
        const forward = new BABYLON.Vector3(Math.sin(chassis.rotation.y), 0, Math.cos(chassis.rotation.y));
        const right = new BABYLON.Vector3(forward.z, 0, -forward.x);

        // Turn car by steering based on forward speed
        const yawRate = steerAngle * speed * 0.6; // tune turning response
        chassis.rotation.y += yawRate * dt;

        // Forces: engine, brake, resistance
        let engineForce = wantThrottle * TUNING.engineForce;
        const brakeForce = (wantBrake * TUNING.brakeForce) + (wantHandbrake * TUNING.handbrakeForce);

        // Limit top speed
        if (speedKmh > TUNING.maxSpeedKmh && engineForce > 0) engineForce = 0;

        // Project velocity onto forward/right to simulate drift & scrub
        const vForward = BABYLON.Vector3.Dot(vel, forward);
        const vRight = BABYLON.Vector3.Dot(vel, right);

        // Longitudinal forces
        const forceLong = forward.scale(engineForce - Math.sign(vForward) * (TUNING.drag * vForward * vForward + TUNING.rollingResistance));
        // Lateral friction (kills side slip)
        const lateralFriction = right.scale(-vRight * 1400);

        // Brakes oppose forward motion
        const brake = forward.scale(-Math.sign(vForward) * brakeForce);

        // Apply forces to chassis center of mass
        chassis.physicsImpostor.applyForce(forceLong, chassis.getAbsolutePosition());
        chassis.physicsImpostor.applyForce(lateralFriction, chassis.getAbsolutePosition());
        if (wantBrake || wantHandbrake) chassis.physicsImpostor.applyForce(brake, chassis.getAbsolutePosition());

        // Simple gear display
        if (speedKmh < 2 && wantBrake && !wantThrottle) gearEl.textContent = 'R';
        else if (speedKmh < 3 && !wantThrottle && !wantBrake) gearEl.textContent = 'N';
        else gearEl.textContent = 'D';
      });

      // Beginner lesson goals (placeholders)
      const checkpoints = [];
      const cpMat = new BABYLON.StandardMaterial('cpMat', scene); cpMat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.2);
      for (let i = 0; i < 5; i++) {
        const ring = BABYLON.MeshBuilder.CreateTorus(`cp_${i}`, { diameter: 5, thickness: 0.2 }, scene);
        ring.position.set((i % 2 === 0 ? -6 : 6), 2.5, 180 - i * 70);
        ring.material = cpMat; ring.isPickable = false; checkpoints.push(ring);
      }

      return scene;
    };

    const scene = createScene();

    engine.runRenderLoop(() => {
      scene.render();
    });

    window.addEventListener('resize', () => engine.resize());
  </script>
</body>
</html>
